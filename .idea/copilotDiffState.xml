<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/sauceDemo/bases/BaseTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/sauceDemo/bases/BaseTest.java" />
              <option name="originalContent" value="package com.sauceDemo.bases;&#10;&#10;import org.apache.commons.io.FileUtils;&#10;import org.openqa.selenium.OutputType;&#10;import org.openqa.selenium.TakesScreenshot;&#10;import org.openqa.selenium.WebDriver;&#10;import org.openqa.selenium.chrome.ChromeDriver;&#10;import org.openqa.selenium.chrome.ChromeOptions;&#10;import org.openqa.selenium.edge.EdgeDriver;&#10;import org.openqa.selenium.firefox.FirefoxDriver;&#10;import org.openqa.selenium.firefox.FirefoxOptions;&#10;import org.testng.ITestContext;&#10;import org.testng.ITestResult;&#10;import org.testng.annotations.AfterMethod;&#10;import org.testng.annotations.BeforeMethod;&#10;import org.testng.annotations.Optional;&#10;import org.testng.annotations.Parameters;&#10;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import java.text.SimpleDateFormat;&#10;import java.time.Duration;&#10;import java.util.Date;&#10;&#10;public class BaseTest {&#10;&#10;    // ThreadLocal to manage WebDriver instances for parallel execution&#10;    private static ThreadLocal&lt;WebDriver&gt; driver = new ThreadLocal&lt;&gt;();&#10;&#10;    // Getter for WebDriver instance specific to the current thread&#10;    public WebDriver getDriver() {&#10;        return driver.get();&#10;    }&#10;&#10;    @BeforeMethod&#10;    @Parameters({&quot;browser&quot;, &quot;incognito&quot;, &quot;headless&quot;})&#10;    public void setup(@Optional(&quot;chrome&quot;) String browser,&#10;                      @Optional(&quot;false&quot;) boolean incognito,&#10;                      @Optional(&quot;false&quot;) boolean headless,&#10;                      ITestContext context) {&#10;&#10;        WebDriver webDriver;&#10;        StringBuilder browserModeInfo = new StringBuilder(browser); // To build string for Extent Report&#10;&#10;        switch (browser.toLowerCase()) {&#10;&#10;            case &quot;chrome&quot;:&#10;                ChromeOptions chromeOptions = new ChromeOptions();&#10;                boolean isSpecialChromeMode = false;&#10;                if (incognito) {&#10;                    chromeOptions.addArguments(&quot;--incognito&quot;);&#10;                    browserModeInfo.append(&quot; (Incognito)&quot;);&#10;                    System.out.println(&quot;Chrome: Running in Incognito mode.&quot;);&#10;                    isSpecialChromeMode = true;&#10;                }&#10;                if (headless) {&#10;                    chromeOptions.addArguments(&quot;--headless=new&quot;); // For newer Chrome versions&#10;                    browserModeInfo.append(&quot; (Headless)&quot;);&#10;                    System.out.println(&quot;Chrome: Running in Headless mode.&quot;);&#10;                    isSpecialChromeMode = true;&#10;                }&#10;&#10;                if (!isSpecialChromeMode) {&#10;                    browserModeInfo.append(&quot; (Standard)&quot;);&#10;                    System.out.println(&quot;Chrome: Running in Standard mode.&quot;);&#10;                }&#10;&#10;                // Add other common headless arguments for robustness (only if headless)&#10;                if (headless) {&#10;                    chromeOptions.addArguments(&quot;--disable-gpu&quot;);&#10;                    chromeOptions.addArguments(&quot;--window-size=1920,1080&quot;);&#10;                    chromeOptions.addArguments(&quot;--no-sandbox&quot;); // Bypass OS security model (Linux only)&#10;                    chromeOptions.addArguments(&quot;--disable-dev-shm-usage&quot;); // Overcome limited resource problems&#10;                }&#10;                webDriver = new ChromeDriver(chromeOptions);&#10;                break;&#10;&#10;            case &quot;firefox&quot;:&#10;                FirefoxOptions firefoxOptions = new FirefoxOptions();&#10;                boolean isSpecialFirefoxMode = false;&#10;&#10;                if (incognito) {&#10;                    firefoxOptions.addArguments(&quot;-private&quot;); // Firefox private mode&#10;                    browserModeInfo.append(&quot; (Private)&quot;);&#10;                    System.out.println(&quot;Firefox: Running in Private mode.&quot;);&#10;                    isSpecialFirefoxMode = true;&#10;                }&#10;                if (headless) {&#10;                    firefoxOptions.addArguments(&quot;-headless&quot;);&#10;                    browserModeInfo.append(&quot; (Headless)&quot;);&#10;                    System.out.println(&quot;Firefox: Running in Headless mode.&quot;);&#10;                    isSpecialFirefoxMode = true;&#10;                }&#10;&#10;                if (!isSpecialFirefoxMode) {&#10;                    browserModeInfo.append(&quot; (Standard)&quot;);&#10;                    System.out.println(&quot;firefox: Running in Standard mode.&quot;);&#10;                }&#10;                webDriver = new FirefoxDriver(firefoxOptions);&#10;                break;&#10;&#10;            case &quot;edge&quot;:&#10;                webDriver = new EdgeDriver();&#10;                browserModeInfo.append(&quot; (Standard)&quot;);&#10;                System.out.println(&quot;Edge: Running in standard mode.&quot;);&#10;                break;&#10;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;Unsupported browser: &quot; + browser);&#10;        }&#10;&#10;        webDriver.manage().window().maximize();&#10;        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));&#10;&#10;        driver.set(webDriver); // Set WebDriver for the current thread&#10;&#10;        // Store WebDriver and BrowserMode in ITestContext for TestListener&#10;        context.setAttribute(&quot;WebDriver&quot;, webDriver);&#10;        context.setAttribute(&quot;BrowserMode&quot;, browserModeInfo.toString());&#10;&#10;        System.out.println(&quot;Browser setup: &quot; + browser + &quot; initialized. Mode: &quot; + browserModeInfo.toString());&#10;    }&#10;&#10;    @AfterMethod&#10;    public void teardown(ITestResult result) {&#10;        if (getDriver() != null) {&#10;            getDriver().quit(); // Quits the browser&#10;            driver.remove(); // Removes the WebDriver instance from ThreadLocal&#10;            System.out.println(&quot;Browser session closed.&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Takes a screenshot of the current browser state.&#10;     * Returns the relative path to the screenshot (e.g., &quot;screenshots/image.png&quot;) relative to the reports folder.&#10;     */&#10;    public static String takeScreenshot(WebDriver driver, String methodName) {&#10;        if (driver == null || !(driver instanceof TakesScreenshot)) {&#10;            System.err.println(&quot;Screenshot error: WebDriver is null or does not support screenshots.&quot;);&#10;            return null;&#10;        }&#10;&#10;        TakesScreenshot ts = (TakesScreenshot) driver;&#10;        File source = ts.getScreenshotAs(OutputType.FILE);&#10;&#10;        String timestamp = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;).format(new Date());&#10;        String fileName = methodName + &quot;_&quot; + timestamp + &quot;.png&quot;;&#10;&#10;        // Screenshots will be saved inside the &quot;reports&quot; directory, in a &quot;screenshots&quot; subfolder.&#10;        String screenshotsDirPath = System.getProperty(&quot;user.dir&quot;) + File.separator + &quot;reports&quot; + File.separator + &quot;screenshots&quot;;&#10;        File screenshotsDir = new File(screenshotsDirPath);&#10;        if (!screenshotsDir.exists()) {&#10;            screenshotsDir.mkdirs(); // Ensure directory exists&#10;        }&#10;&#10;        File destination = new File(screenshotsDir, fileName);&#10;&#10;        try {&#10;            FileUtils.copyFile(source, destination);&#10;            // Return path relative to the HTML report. If report is in /reports and screenshot in /reports/screenshots,&#10;            // then the path within the report is simply &quot;screenshots/filename.png&quot;&#10;            String relativePathForReport = &quot;screenshots&quot; + File.separator + fileName;&#10;            System.out.println(&quot;Screenshot saved: &quot; + destination.getName());&#10;            return relativePathForReport.replace(File.separator, &quot;/&quot;); // Ensure forward slashes for HTML path&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Failed to save screenshot: &quot; + destination.getName() + &quot; - &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.sauceDemo.bases;&#10;&#10;import org.apache.commons.io.FileUtils;&#10;import org.openqa.selenium.OutputType;&#10;import org.openqa.selenium.TakesScreenshot;&#10;import org.openqa.selenium.WebDriver;&#10;import org.openqa.selenium.chrome.ChromeDriver;&#10;import org.openqa.selenium.chrome.ChromeOptions;&#10;import org.openqa.selenium.edge.EdgeDriver;&#10;import org.openqa.selenium.firefox.FirefoxDriver;&#10;import org.openqa.selenium.firefox.FirefoxOptions;&#10;import org.testng.ITestContext;&#10;import org.testng.ITestResult;&#10;import org.testng.annotations.AfterMethod;&#10;import org.testng.annotations.BeforeMethod;&#10;import org.testng.annotations.Optional;&#10;import org.testng.annotations.Parameters;&#10;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import java.text.SimpleDateFormat;&#10;import java.time.Duration;&#10;import java.util.Date;&#10;&#10;public class BaseTest {&#10;&#10;    // ThreadLocal to manage WebDriver instances for parallel execution&#10;    private static ThreadLocal&lt;WebDriver&gt; driver = new ThreadLocal&lt;&gt;();&#10;&#10;    // Getter for WebDriver instance specific to the current thread&#10;    public WebDriver getDriver() {&#10;        return driver.get();&#10;    }&#10;&#10;    @BeforeMethod&#10;    @Parameters({&quot;browser&quot;, &quot;incognito&quot;, &quot;headless&quot;})&#10;    public void setup(@Optional(&quot;chrome&quot;) String browser,&#10;                      @Optional(&quot;false&quot;) boolean incognito,&#10;                      @Optional(&quot;false&quot;) boolean headless,&#10;                      ITestContext context) {&#10;&#10;        WebDriver webDriver;&#10;        StringBuilder browserModeInfo = new StringBuilder(browser); // To build string for Extent Report&#10;&#10;        switch (browser.toLowerCase()) {&#10;&#10;            case &quot;chrome&quot;:&#10;                ChromeOptions chromeOptions = new ChromeOptions();&#10;                boolean isSpecialChromeMode = false;&#10;                if (incognito) {&#10;                    chromeOptions.addArguments(&quot;--incognito&quot;);&#10;                    browserModeInfo.append(&quot; (Incognito)&quot;);&#10;                    System.out.println(&quot;Chrome: Running in Incognito mode.&quot;);&#10;                    isSpecialChromeMode = true;&#10;                }&#10;                if (headless) {&#10;                    chromeOptions.addArguments(&quot;--headless=new&quot;); // For newer Chrome versions&#10;                    browserModeInfo.append(&quot; (Headless)&quot;);&#10;                    System.out.println(&quot;Chrome: Running in Headless mode.&quot;);&#10;                    isSpecialChromeMode = true;&#10;                }&#10;&#10;                if (!isSpecialChromeMode) {&#10;                    browserModeInfo.append(&quot; (Standard)&quot;);&#10;                    System.out.println(&quot;Chrome: Running in Standard mode.&quot;);&#10;                }&#10;&#10;                // Add other common headless arguments for robustness (only if headless)&#10;                if (headless) {&#10;                    chromeOptions.addArguments(&quot;--disable-gpu&quot;);&#10;                    chromeOptions.addArguments(&quot;--window-size=1920,1080&quot;);&#10;                    chromeOptions.addArguments(&quot;--no-sandbox&quot;); // Bypass OS security model (Linux only)&#10;                    chromeOptions.addArguments(&quot;--disable-dev-shm-usage&quot;); // Overcome limited resource problems&#10;                }&#10;                webDriver = new ChromeDriver(chromeOptions);&#10;                break;&#10;&#10;            case &quot;firefox&quot;:&#10;                FirefoxOptions firefoxOptions = new FirefoxOptions();&#10;                boolean isSpecialFirefoxMode = false;&#10;&#10;                if (incognito) {&#10;                    firefoxOptions.addArguments(&quot;-private&quot;); // Firefox private mode&#10;                    browserModeInfo.append(&quot; (Private)&quot;);&#10;                    System.out.println(&quot;Firefox: Running in Private mode.&quot;);&#10;                    isSpecialFirefoxMode = true;&#10;                }&#10;                if (headless) {&#10;                    firefoxOptions.addArguments(&quot;-headless&quot;);&#10;                    browserModeInfo.append(&quot; (Headless)&quot;);&#10;                    System.out.println(&quot;Firefox: Running in Headless mode.&quot;);&#10;                    isSpecialFirefoxMode = true;&#10;                }&#10;&#10;                if (!isSpecialFirefoxMode) {&#10;                    browserModeInfo.append(&quot; (Standard)&quot;);&#10;                    System.out.println(&quot;firefox: Running in Standard mode.&quot;);&#10;                }&#10;                webDriver = new FirefoxDriver(firefoxOptions);&#10;                break;&#10;&#10;            case &quot;edge&quot;:&#10;                webDriver = new EdgeDriver();&#10;                browserModeInfo.append(&quot; (Standard)&quot;);&#10;                System.out.println(&quot;Edge: Running in standard mode.&quot;);&#10;                break;&#10;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;Unsupported browser: &quot; + browser);&#10;        }&#10;&#10;        webDriver.manage().window().maximize();&#10;        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));&#10;&#10;        driver.set(webDriver); // Set WebDriver for the current thread&#10;&#10;        // Store WebDriver and BrowserMode in ITestContext for TestListener&#10;        context.setAttribute(&quot;WebDriver&quot;, webDriver);&#10;        context.setAttribute(&quot;BrowserMode&quot;, browserModeInfo.toString());&#10;&#10;        System.out.println(&quot;Browser setup: &quot; + browser + &quot; initialized. Mode: &quot; + browserModeInfo.toString());&#10;    }&#10;&#10;    @AfterMethod&#10;    public void teardown(ITestResult result) {&#10;        if (getDriver() != null) {&#10;            getDriver().quit(); // Quits the browser&#10;            driver.remove(); // Removes the WebDriver instance from ThreadLocal&#10;            System.out.println(&quot;Browser session closed.&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Takes a screenshot of the current browser state.&#10;     * Returns the relative path to the screenshot (e.g., &quot;screenshots/image.png&quot;) relative to the reports folder.&#10;     */&#10;    public static String takeScreenshot(WebDriver driver, String methodName) {&#10;        if (driver == null || !(driver instanceof TakesScreenshot)) {&#10;            System.err.println(&quot;Screenshot error: WebDriver is null or does not support screenshots.&quot;);&#10;            return null;&#10;        }&#10;&#10;        TakesScreenshot ts = (TakesScreenshot) driver;&#10;        File source = ts.getScreenshotAs(OutputType.FILE);&#10;&#10;        String timestamp = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;).format(new Date());&#10;        String fileName = methodName + &quot;_&quot; + timestamp + &quot;.png&quot;;&#10;&#10;        // Screenshots will be saved inside the &quot;reports&quot; directory, in a &quot;screenshots&quot; subfolder.&#10;        String screenshotsDirPath = System.getProperty(&quot;user.dir&quot;) + File.separator + &quot;reports&quot; + File.separator + &quot;screenshots&quot;;&#10;        File screenshotsDir = new File(screenshotsDirPath);&#10;        if (!screenshotsDir.exists()) {&#10;            screenshotsDir.mkdirs(); // Ensure directory exists&#10;        }&#10;&#10;        File destination = new File(screenshotsDir, fileName);&#10;&#10;        try {&#10;            FileUtils.copyFile(source, destination);&#10;            // Return path relative to the HTML report. If report is in /reports and screenshot in /reports/screenshots,&#10;            // then the path within the report is simply &quot;screenshots/filename.png&quot;&#10;            String relativePathForReport = &quot;screenshots&quot; + File.separator + fileName;&#10;            System.out.println(&quot;Screenshot saved: &quot; + destination.getName());&#10;            return relativePathForReport.replace(File.separator, &quot;/&quot;); // Ensure forward slashes for HTML path&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Failed to save screenshot: &quot; + destination.getName() + &quot; - &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/log4j2.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/log4j2.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;Configuration status=&quot;INFO&quot;&gt;&#10;    &lt;Appenders&gt;&#10;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;&#10;            &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&gt;&#10;        &lt;/Console&gt;&#10;        &lt;RollingFile name=&quot;File&quot; fileName=&quot;logs/automation.log&quot; filePattern=&quot;logs/automation-%d{yyyy-MM-dd}-%i.log&quot;&gt;&#10;            &lt;PatternLayout pattern=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&gt;&#10;            &lt;Policies&gt;&#10;                &lt;SizeBasedTriggeringPolicy size=&quot;10MB&quot;/&gt;&#10;            &lt;/Policies&gt;&#10;            &lt;DefaultRolloverStrategy max=&quot;5&quot;/&gt;&#10;        &lt;/RollingFile&gt;&#10;    &lt;/Appenders&gt;&#10;    &lt;Loggers&gt;&#10;        &lt;Root level=&quot;info&quot;&gt;&#10;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;&#10;            &lt;AppenderRef ref=&quot;File&quot;/&gt;&#10;        &lt;/Root&gt;&#10;    &lt;/Loggers&gt;&#10;&lt;/Configuration&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;Configuration status=&quot;INFO&quot;&gt;&#10;    &lt;Appenders&gt;&#10;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;&#10;            &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&gt;&#10;        &lt;/Console&gt;&#10;        &lt;RollingFile name=&quot;File&quot; fileName=&quot;logs/automation.log&quot; filePattern=&quot;logs/automation-%d{yyyy-MM-dd}-%i.log&quot;&gt;&#10;            &lt;PatternLayout pattern=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&gt;&#10;            &lt;Policies&gt;&#10;                &lt;SizeBasedTriggeringPolicy size=&quot;10MB&quot;/&gt;&#10;            &lt;/Policies&gt;&#10;            &lt;DefaultRolloverStrategy max=&quot;5&quot;/&gt;&#10;        &lt;/RollingFile&gt;&#10;    &lt;/Appenders&gt;&#10;    &lt;Loggers&gt;&#10;        &lt;Root level=&quot;info&quot;&gt;&#10;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;&#10;            &lt;AppenderRef ref=&quot;File&quot;/&gt;&#10;        &lt;/Root&gt;&#10;    &lt;/Loggers&gt;&#10;&lt;/Configuration&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>